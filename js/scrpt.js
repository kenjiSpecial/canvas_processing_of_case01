// Generated by CoffeeScript 1.5.0
(function() {
  var Line, agent, canvas, clear, context, hig, mobileStatus, mouseX, mouseY, mouse_move, myLine, randomVal, step, touch_move, wid;

  randomVal = function(minVal, maxVal) {
    return (maxVal - minVal) * Math.random() + minVal;
  };

  Line = (function() {
    var LineNum, frict;

    LineNum = 50;

    frict = 0.9;

    function Line(context, wid, hig) {
      var i, _i, _ref;
      this.context = context;
      this.wid = wid;
      this.hig = hig;
      this.lastPos = [];
      this.pos = [];
      this.velocity = [];
      this.friction = [];
      this.ease = [];
      for (i = _i = 0, _ref = LineNum - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.pos[i] = {
          x: this.wid * randomVal(.1, .9),
          y: this.hig * randomVal(0.1, 0.9)
        };
        this.lastPos[i] = {
          x: this.pos[i].x,
          y: this.pos[i].y
        };
        this.velocity[i] = {
          x: 0,
          y: 0
        };
        this.friction[i] = {
          x: randomVal(10, 40),
          y: randomVal(10, 40)
        };
        this.ease[i] = {
          x: randomVal(2, 10),
          y: randomVal(2, 10)
        };
      }
    }

    Line.prototype.update = function(mouseX, mouseY) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = LineNum - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.lastPos[i].x = this.pos[i].x;
        this.lastPos[i].y = this.pos[i].y;
        this.pos[i].x += this.velocity[i].x;
        this.pos[i].y += this.velocity[i].y;
        this.velocity[i].x += (((mouseX - this.pos[i].x) * this.ease[i].x) - this.velocity[i].x) / this.friction[i].x;
        this.velocity[i].y += (((mouseY - this.pos[i].y) * this.ease[i].y) - this.velocity[i].y) / this.friction[i].y;
        this.velocity[i].x *= frict;
        _results.push(this.velocity[i].y *= frict);
      }
      return _results;
    };

    Line.prototype.draw = function() {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = LineNum - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.context.lineCap = 'round';
        this.context.lineJoin = 'round';
        this.context.beginPath();
        this.context.strokeStyle = "#fff";
        this.context.moveTo(this.lastPos[i].x, this.lastPos[i].y);
        this.context.lineTo(this.pos[i].x, this.pos[i].y);
        this.context.stroke();
        _results.push(this.context.closePath());
      }
      return _results;
    };

    return Line;

  })();

  mobileStatus;

  agent = navigator.userAgent;

  if (agent.search(/iPhone/) !== -1 || agent.search(/iPad/) !== -1 || agent.search(/iPod/) !== -1 || agent.search(/Android/) !== -1) {
    mobileStatus = true;
  } else {
    mobileStatus = false;
  }

  window.requestAnimationFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  wid = window.innerWidth;

  hig = window.innerHeight;

  mouseX = wid / 2;

  mouseY = hig / 2;

  canvas = document.getElementById("myCanvas");

  canvas.width = wid;

  canvas.height = hig;

  context = canvas.getContext("2d");

  context.fillStyle = "#000";

  context.fillRect(0, 0, wid, hig);

  myLine = new Line(context, wid, hig);

  touch_move = function(e) {
    var touch;
    touch = e.touches[0];
    mouseX = touch.pageX;
    mouseY = touch.pageY;
    return e.preventDefault();
  };

  mouse_move = function(e) {
    mouseX = e.x;
    return mouseY = e.y;
  };

  if (mobileStatus) {
    document.addEventListener("touchmove", touch_move);
  } else {
    document.addEventListener("mousemove", mouse_move);
  }

  clear = function() {
    context.fillStyle = "rgba(0, 0, 0, .05)";
    return context.fillRect(0, 0, wid, hig);
  };

  step = function() {
    clear();
    myLine.update(mouseX, mouseY);
    myLine.draw();
    return requestAnimationFrame(step);
  };

  step();

}).call(this);
